using System.Collections.Concurrent;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Neko.AbstractionLayer;
using Neko.EntityComponentSystem;
using Neko.Extensions.Logging;
using Neko.Rendering.Renderer2D.Interfaces;
using Neko.Rendering.Renderer2D.Models;
using Neko.Vulkan;
using Vortice.Vulkan;

namespace Neko.Rendering.Renderer2D;

public readonly struct CmdRef(uint pool, int cmdIndex) {
  public readonly uint Pool = pool;
  public readonly int CmdIndex = cmdIndex;
}

public class Render2DSystem : SystemBase {
  public IDrawable2D[] Cache { get; private set; } = [];
  private IDrawable2D[] _visibleCache = [];

  public ulong LastKnownElemSize { get; private set; } = 0;
  public int LastKnownElemCount { get; private set; } = 0;

  private NekoBuffer[] _indirectBuffers = [];
  private Dictionary<uint, IndirectData> _indirectData = [];
  private uint _instanceIndex;

  private BufferPool? _bufferPool;
  private readonly List<VertexBinding> _vertexBindings = [];

  private bool _cacheMatch = false;
  private readonly Dictionary<Guid, float> _texIndexCache = [];

  private SpritePushConstant140[] _spriteDataScratch = [];
  private readonly Dictionary<IDrawable2D, int> _drawableToSpriteIndex = [];

  private IDrawable2D[] _drawablesCache = [];

  private readonly Dictionary<uint, List<VkDrawIndexedIndirectCommand>> _visibleScratch = [];
  private readonly Dictionary<IDrawable2D, CmdRef> _cmdMap = [];

  private bool _invalid = false;

  public Render2DSystem(
    Application app,
    nint allocator,
    VulkanDevice device,
    IRenderer renderer,
    TextureManager textureManager,
    Dictionary<string, IDescriptorSetLayout> externalLayouts,
    IPipelineConfigInfo configInfo = null!
  ) : base(app, allocator, device, renderer, textureManager, configInfo) {
    IDescriptorSetLayout[] descriptorSetLayouts = [
      externalLayouts["Global"],
      externalLayouts["SpriteData"],
      _textureManager.AllTexturesSetLayout,
    ];

    AddPipelineData(new() {
      RenderPass = renderer.GetSwapchainRenderPass(),
      VertexName = "sprite_vertex",
      FragmentName = "sprite_fragment",
      PipelineProvider = new PipelineSpriteProvider(),
      DescriptorSetLayouts = descriptorSetLayouts,
    });

    _descriptorPool = new VulkanDescriptorPool.Builder(_device)
      .SetMaxSets(CommonConstants.MAX_SETS)
      .AddPoolSize(DescriptorType.UniformBuffer, CommonConstants.MAX_SETS)
      .AddPoolSize(DescriptorType.SampledImage, CommonConstants.MAX_SETS)
      .AddPoolSize(DescriptorType.Sampler, CommonConstants.MAX_SETS)
      .AddPoolSize(DescriptorType.InputAttachment, CommonConstants.MAX_SETS)
      .AddPoolSize(DescriptorType.StorageBuffer, CommonConstants.MAX_SETS)
      .SetPoolFlags(DescriptorPoolCreateFlags.UpdateAfterBind)
      .Build();

    _bufferPool = new(_device, _allocator);
  }

  public void Setup(ReadOnlySpan<IDrawable2D> drawables, ref TextureManager textures) {
    if (drawables.Length < 1) {
      Logger.Warn("Entities that are capable of using 2D renderer are less than 1, thus 2D Render System won't be recreated");
      return;
    }

    LastKnownElemCount = CalculateLastKnownElemCount(drawables);
  }

  public bool CheckSizes(ReadOnlySpan<IDrawable2D> drawables) {
    var newCount = CalculateLastKnownElemCount(drawables);
    if (newCount != LastKnownElemCount) {
      // LastKnownElemCount = newCount;
      return false;
    }

    return true;
  }
  private static int CalculateTextureCount(ReadOnlySpan<IDrawable2D> drawables) {
    int count = 0;
    for (int i = 0; i < drawables.Length; i++) {
      count += drawables[i].SpriteCount;
    }
    return count;
  }

  private static int CalculateLastKnownElemCount(ReadOnlySpan<IDrawable2D> drawables) {
    int count = 0;
    for (int i = 0; i < drawables.Length; i++) {
      if (drawables[i].Children.Length > 0) {
        count += drawables[i].Children.Length;
      } else {
        count++;
      }
    }

    return count;
  }

  public void Invalidate(IDrawable2D[] drawables) {
    _invalid = true;
    _drawablesCache = drawables;
  }

  public unsafe void Update(FrameInfo frameInfo) {
    if (_spriteDataScratch.Length == 0) return;

    for (int i = 0; i < _visibleCache.Length; i++) {
      var target = _visibleCache[i];
      var owner = target.Entity;
      if (owner.CanBeDisposed) continue;

      int idx = _drawableToSpriteIndex[target];
      ref var sd = ref _spriteDataScratch[idx];

      var myTexId = GetIndexOfMyTexture(target.Texture.TextureName);
      // if (!myTexId.HasValue) throw new ArgumentException("", paramName: myTexId.ToString());

      if (target.LocalZDepth != 0) {
        sd.SpriteMatrix = target.Entity.GetTransform()?.Matrix().OverrideZDepth(target.LocalZDepth) ?? Matrix4x4.Identity;

        sd.SpriteSheetData.X = target.SpriteSheetSize.X;
        sd.SpriteSheetData.Y = target.SpriteSheetSize.Y;
        sd.SpriteSheetData.Z = target.SpriteIndex;
        sd.SpriteSheetData.W = target.FlipX ? 1.0f : 0.0f;

        sd.SpriteSheetData2.X = target.FlipY ? 1.0f : 0.0f;
        sd.SpriteSheetData2.Y = myTexId;
        sd.SpriteSheetData2.Z = -1.0f;
        sd.SpriteSheetData2.W = -1.0f;
      } else {
        sd.SpriteMatrix = target.Entity.GetTransform()?.Matrix() ?? Matrix4x4.Identity;

        sd.SpriteSheetData.X = target.SpriteSheetSize.X;
        sd.SpriteSheetData.Y = target.SpriteSheetSize.Y;
        sd.SpriteSheetData.Z = target.SpriteIndex;
        sd.SpriteSheetData.W = target.FlipX ? 1.0f : 0.0f;

        sd.SpriteSheetData2.X = target.FlipY ? 1.0f : 0.0f;
        sd.SpriteSheetData2.Y = myTexId;
        sd.SpriteSheetData2.Z = -1.0f;
        sd.SpriteSheetData2.W = -1.0f;
      }
    }

    fixed (SpritePushConstant140* pSpriteData = _spriteDataScratch) {
      _application.StorageCollection.WriteBuffer(
        "SpriteStorage",
        frameInfo.FrameIndex,
        (nint)pSpriteData,
        (ulong)Unsafe.SizeOf<SpritePushConstant140>() * (ulong)_spriteDataScratch.Length
      );
    }
  }

  private unsafe void UploadSpriteData(FrameInfo frameInfo) {
    if (_spriteDataScratch.Length == 0) return;

    for (int i = 0; i < _visibleCache.Length; i++) {
      var target = _visibleCache[i];
      var owner = target.Entity;
      if (owner.CanBeDisposed) continue;

      int idx = _drawableToSpriteIndex[target];
      ref var sd = ref _spriteDataScratch[idx];

      var myTexId = GetIndexOfMyTexture(target.Texture.TextureName);

      if (target.LocalZDepth != 0) {
        sd.SpriteMatrix = target.Entity.GetTransform()?.Matrix().OverrideZDepth(target.LocalZDepth) ?? Matrix4x4.Identity;

        sd.SpriteSheetData.X = target.SpriteSheetSize.X;
        sd.SpriteSheetData.Y = target.SpriteSheetSize.Y;
        sd.SpriteSheetData.Z = target.SpriteIndex;
        sd.SpriteSheetData.W = target.FlipX ? 1.0f : 0.0f;

        sd.SpriteSheetData2.X = target.FlipY ? 1.0f : 0.0f;
        sd.SpriteSheetData2.Y = myTexId;
        sd.SpriteSheetData2.Z = -1.0f;
        sd.SpriteSheetData2.W = -1.0f;
      } else {
        sd.SpriteMatrix = target.Entity.GetTransform()?.Matrix() ?? Matrix4x4.Identity;

        sd.SpriteSheetData.X = target.SpriteSheetSize.X;
        sd.SpriteSheetData.Y = target.SpriteSheetSize.Y;
        sd.SpriteSheetData.Z = target.SpriteIndex;
        sd.SpriteSheetData.W = target.FlipX ? 1.0f : 0.0f;

        sd.SpriteSheetData2.X = target.FlipY ? 1.0f : 0.0f;
        sd.SpriteSheetData2.Y = myTexId;
        sd.SpriteSheetData2.Z = -1.0f;
        sd.SpriteSheetData2.W = -1.0f;
      }
    }

    fixed (SpritePushConstant140* pSpriteData = _spriteDataScratch) {
      _application.StorageCollection.WriteBuffer(
        "SpriteStorage",
        frameInfo.FrameIndex,
        (nint)pSpriteData,
        (ulong)Unsafe.SizeOf<SpritePushConstant140>() * (ulong)_spriteDataScratch.Length
      );
    }
  }

  public void Render(FrameInfo frameInfo) {
    CreateOrUpdateBuffers(_drawablesCache);
    uint visible = RefillIndirectBuffersWithCulling();
    if (visible < 1) return;

    RenderIndirect(frameInfo);
  }

  public void RenderIndirect(FrameInfo frameInfo) {
    var canProceed =
      frameInfo.GlobalDescriptorSet.IsNotNull &&
      frameInfo.SpriteDataDescriptorSet.IsNotNull;

    if (!canProceed) return;

    BindPipeline(frameInfo.CommandBuffer);

    Descriptor.BindDescriptorSet(_device, frameInfo.GlobalDescriptorSet, frameInfo, PipelineLayout, 0, 1);
    Descriptor.BindDescriptorSet(_device, _textureManager.AllTexturesDescriptor, frameInfo, PipelineLayout, 2, 1);
    Descriptor.BindDescriptorSet(_device, frameInfo.SpriteDataDescriptorSet, frameInfo, PipelineLayout, 1, 1);

    // Logger.Info("Render");

    foreach (var container in _indirectData) {
      if (_indirectBuffers[container.Key].GetBuffer().IsNull) {
        Logger.Warn("indirect buff for given container is null, skipping");
        continue;
      }

      var targetVertex = _bufferPool?.GetVertexBuffer(container.Key);
      var targetIndex = _bufferPool?.GetIndexBuffer(container.Key);

      if (targetIndex == null || targetVertex == null) {
        Logger.Warn("Either index or vertex from pool is null");
        continue;
      }

      _renderer.CommandList.BindIndex(frameInfo.CommandBuffer, targetIndex!, 0);
      _renderer.CommandList.BindVertex(frameInfo.CommandBuffer, targetVertex, 0);

      _renderer.CommandList.DrawIndexedIndirect(
        frameInfo.CommandBuffer,
        _indirectBuffers[container.Key].GetBuffer(),
        0,
        (uint)container.Value.Commands.Count,
        (uint)Unsafe.SizeOf<VkDrawIndexedIndirectCommand>()
      );

      // Logger.Info("Inner Render");
    }
  }

  private void CreateOrUpdateBuffers(ReadOnlySpan<IDrawable2D> drawables) {
    _cacheMatch = _drawablesCache.SequenceEqual(drawables) && !_invalid;
    if (!_invalid && _bufferPool != null) return;

    _instanceIndex = 0;

    Cache = [.. drawables];
    _invalid = false;
    int totalObjs = Cache.Length;

    _spriteDataScratch = (totalObjs == 0) ? [] : new SpritePushConstant140[totalObjs];

    _drawableToSpriteIndex.Clear();
    for (int i = 0; i < totalObjs; i++) {
      _drawableToSpriteIndex[Cache[i]] = i;
    }

    _texIndexCache.Clear();

    Logger.Info($"Total 2D Objs: {totalObjs}");

    if (totalObjs > 0) {
      CreateVertexIndexBuffer(Cache);
    }

    EnsureIndirectBuffers(_indirectData, ref _indirectBuffers);

    _cacheMatch = true;

    for (int i = 0; i < Cache.Length; i++) {
      var target = Cache[i];
      var owner = target.Entity;
      if (owner.CanBeDisposed) continue;

      var tex = target.Texture;
      var guid = _textureManager.GetTextureIdLocal(tex.TextureName);
      float texId = GetOrAddTextureIndex(guid);

      // ref var sd = ref _spriteDataScratch[i];
      // sd.SpriteSheetData2.Y = texId;
    }

    EnsureVisibleScratchCapacity();
  }

  private float GetOrAddTextureIndex(Guid textureId) {
    ref float texId = ref CollectionsMarshal.GetValueRefOrAddDefault(
      _texIndexCache,
      textureId,
      out var exists
    );

    if (!exists) {
      var targetTexture = _textureManager.GetTextureLocal(textureId);
      texId = GetIndexOfMyTexture(targetTexture.TextureName);
    }

    return texId;
  }

  private void EnsureVisibleScratchCapacity() {
    foreach (var (pool, data) in _indirectData) {
      if (!_visibleScratch.TryGetValue(pool, out var list))
        _visibleScratch[pool] = new List<VkDrawIndexedIndirectCommand>(data.Commands.Count);
      else if (list.Capacity < data.Commands.Count)
        list.Capacity = data.Commands.Count;
    }
  }

  private unsafe void EnsureIndirectBuffers(
  Dictionary<uint, IndirectData> pair,
  ref NekoBuffer[] buffArray
) {
    // Make sure the array can index directly by 'pool key'
    int maxKey = pair.Count == 0 ? -1 : (int)pair.Keys.Max();
    if (maxKey < 0) { buffArray = []; return; }

    if (buffArray == null || buffArray.Length <= maxKey) {
      // grow but DO NOT touch existing buffers
      var newArr = new NekoBuffer[maxKey + 1];
      if (buffArray != null) Array.Copy(buffArray, newArr, buffArray.Length);
      buffArray = newArr;
    }

    foreach (var kv in pair) {
      uint pool = kv.Key;
      var data = kv.Value;
      ulong neededBytes = (ulong)data.Commands.Count * (ulong)Unsafe.SizeOf<VkDrawIndexedIndirectCommand>();

      var existing = buffArray[pool];
      bool needsAlloc = existing == null || existing.GetBufferSize() < neededBytes;

      if (!needsAlloc) continue;

      existing?.Dispose();

      var inBuff = new NekoBuffer(
        _allocator,
        _device,
        neededBytes,
        BufferUsage.IndirectBuffer,
        MemoryProperty.HostVisible | MemoryProperty.HostCoherent,
        stagingBuffer: false,
        cpuAccessible: true
      );

      inBuff.Map(neededBytes);

      buffArray[pool] = inBuff;

      var span = CollectionsMarshal.AsSpan(data.Commands);
      if (span.Length > 0) {
        ref var first = ref MemoryMarshal.GetReference(span);
        fixed (VkDrawIndexedIndirectCommand* p = &first) {
          inBuff.WriteToBuffer((nint)p, neededBytes, 0);
          inBuff.Flush(neededBytes, 0);
        }
      }
    }
  }


  private static int GetIndexOfMyTexture(string texName) {
    var texturePair = Application.Instance.TextureManager.PerSceneLoadedTextures
      .Where(x => x.Value.TextureName == texName)
      .Single();
    return texturePair.Value.TextureManagerIndex;
  }

  // private static int? GetIndexOfMyTexture(string texName) {
  //   return Application.Instance.TextureManager.PerSceneLoadedTextures
  //     .Where(x => x.Value.TextureName == texName)
  //     .FirstOrDefault()
  //     .Value.TextureManagerIndex;
  // }

  private uint RefillIndirectBuffersWithCulling() {
    foreach (var s in _visibleScratch.Values) s.Clear();

    _visibleCache = [.. Cache];

    foreach (var n in _visibleCache) {
      var owner = n.Entity;
      if (owner.CanBeDisposed || !owner.Active) continue;
      if (n.Mesh?.IndexCount < 1) continue;

      if (!_cmdMap.TryGetValue(n, out var r)) continue;
      var src = _indirectData[r.Pool].Commands[r.CmdIndex];

      if (!_visibleScratch.TryGetValue(r.Pool, out var list)) {
        list = new List<VkDrawIndexedIndirectCommand>(32);
        _visibleScratch[r.Pool] = list;
      }
      list.Add(src);
    }

    foreach (var kv in _visibleScratch) {
      var pool = kv.Key;
      var list = kv.Value;
      _indirectData[pool].VisibleCount = list.Count;
      var targetBuffer = _indirectBuffers![pool];
      CopyCmdListToBuffer(list, targetBuffer);
    }

    uint total = 0;
    foreach (var d in _indirectData.Values) total += (uint)d.VisibleCount;
    return (uint)Cache.Length;
  }

  private static unsafe void CopyCmdListToBuffer(List<VkDrawIndexedIndirectCommand> list, NekoBuffer buf) {
    var span = CollectionsMarshal.AsSpan(list);
    if (span.Length == 0) return;

    ref var first = ref MemoryMarshal.GetReference(span);
    fixed (VkDrawIndexedIndirectCommand* p = &first) {
      ulong bytes = (ulong)span.Length * (ulong)Unsafe.SizeOf<VkDrawIndexedIndirectCommand>();
      buf.WriteToBuffer((nint)p, bytes, 0);
      buf.Flush(bytes, 0);
    }
  }

  private void AddIndirectCommand(
    uint index,
    IDrawable2D drawable,
    VertexBinding vertexBinding,
    ref Dictionary<uint, IndirectData> pair,
    ref uint instanceIndex,
    in uint additionalIndexOffset = 0
  ) {
    if (!pair.ContainsKey(index)) {
      var id = pair.Keys.Count;
      pair.Add((uint)id, new());
    }

    var data = pair[index];

    var mesh = drawable.Mesh;
    if (mesh.IndexCount < 1) throw new ArgumentNullException("mesh does not have indices", nameof(mesh));

    var cmd = new VkDrawIndexedIndirectCommand {
      indexCount = (uint)mesh.Indices.Length,
      instanceCount = 1,
      firstIndex = vertexBinding.FirstIndexOffset,
      vertexOffset = (int)vertexBinding.FirstVertexOffset,
      firstInstance = instanceIndex + additionalIndexOffset
    };

    pair[index].Commands.Add(cmd);

    instanceIndex++;
    data.CurrentIndexOffset += vertexBinding.FirstIndexOffset;
  }

  private unsafe void CreateVertexIndexBuffer(ReadOnlySpan<IDrawable2D> drawables) {
    _bufferPool?.Dispose();
    _bufferPool = new BufferPool(_device, _allocator);
    _indirectData.Clear();

    var indexOffset = 0u;
    var vertexOffset = 0u;

    var accumulatedIndexSize = 0u;
    var accumulatedVertexSize = 0ul;

    var currentPool = 0u;
    _bufferPool.CreateNewBakeData(currentPool);

    Cache = drawables.ToArray();
    foreach (var drawable in drawables) {
      var mesh = drawable.Mesh;
      var verts = drawable.Mesh!.Vertices;
      var indices = drawable.Mesh!.Indices;

      var vertexByteSize = (ulong)verts.Length * (ulong)Unsafe.SizeOf<Vertex>();
      var indexByteSize = (uint)indices.Length * sizeof(uint);

      accumulatedVertexSize += vertexByteSize;
      accumulatedIndexSize += indexByteSize;

      var canAddVertex = _bufferPool.CanBakeMoreVertex(currentPool, accumulatedVertexSize);
      var canAddIndex = _bufferPool.CanBakeMoreIndex(currentPool, accumulatedIndexSize);

      if (!canAddIndex || !canAddVertex) {
        currentPool++;
        _bufferPool.CreateNewBakeData(currentPool);
        indexOffset = 0;
        vertexOffset = 0;
        accumulatedIndexSize = 0;
        accumulatedVertexSize = 0;
      }

      // var localIndices = new List<uint>();
      // foreach (var idx in meshes[node.MeshGuid].Indices) {
      //   adjustedIndices.Add(idx + vertexOffset);
      //   localIndices.Add(idx + vertexOffset);
      // }

      _bufferPool.AddIndexToBake(currentPool, [.. indices]);
      _bufferPool.AddVertexToBake(currentPool, [.. verts]);

      _vertexBindings.Add(new VertexBinding {
        BufferIndex = currentPool,
        FirstVertexOffset = vertexOffset,
        FirstIndexOffset = indexOffset
      });

      AddIndirectCommand(
        currentPool,
        drawable, _vertexBindings.Last(),
        ref _indirectData,
        ref _instanceIndex
      );

      indexOffset += (uint)indices.Length;
      vertexOffset += (uint)verts.Length;
    }

    _bufferPool.BakeAll();
  }
  public void Dispose(bool skipBase = false) {
    _device.WaitQueue();
    foreach (var buff in _indirectBuffers) {
      buff.Dispose();
    }
    _indirectBuffers = [];
    if (!skipBase) {
      base.Dispose();
    }
  }
}
